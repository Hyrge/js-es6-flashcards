> [!note]
> ### 📌 결론 요약
> - `for...in`: **객체 key 반복용**. 배열에는 비추. 순서 보장 안 됨. 반복 중 객체 수정 ❌
> - `for...of`: **배열/문자열 값 반복용**. 순서 보장. 이터러블에만 사용 가능

    

### ✅ `for...in` vs `for...of`의 핵심 차이

| 구문         | 용도                 | 대상                 | 순서 보장 여부   | 반복 대상     |
| ---------- | ------------------ | ------------------ | ---------- | --------- |
| `for...in` | **객체의 속성(key)** 반복 | 객체, 배열 등           | ❌ 순서 보장 없음 | key (문자열) |
| `for...of` | **값(value)** 반복    | 배열, 문자열 등 **이터러블** | ✅ 순서 보장    | 실제 값      |

---

### 🔍 본문 설명 해석해주면?

> `for in` 루프는 순서 없이 객체의 모든 열거 가능한 속성을 반복한다

→ `for in`은 객체의 **속성명(키)** 을 반복하는데, 그 순서가 **예측되지 않을 수도 있음**.

```js
const obj = { b: 2, a: 1, c: 3 };
for (const key in obj) {
  console.log(key);
}
// 출력 순서: b, a, c 일 수도 있고, a, b, c 일 수도 있음 (명세상 보장 안 됨)
```

---

> 반복 중에는 객체의 속성을 추가, 수정, 삭제하지 않는 것이 좋다

→ 반복 도중에 객체를 바꾸면, 어떤 일이 생길지 예측할 수 없기 때문이야.  
예를 들어 반복 중간에 키를 **추가하거나 삭제하면**, 그 키가 반복 대상이 될 수도 있고 안 될 수도 있음.  
즉, **변화한 상태가 언제 반영될지 보장되지 않음**.

```js
const obj = { a: 1, b: 2 };
for (const key in obj) {
  console.log(key);
  obj.c = 3; // 반복 중에 속성 추가
}
// 'c'는 출력될 수도 있고, 안 될 수도 있음 (예측불가)
```

---

### 💡 `for...of`는?

```js
const arr = ['a', 'b', 'c'];
for (const item of arr) {
  console.log(item);
}
```

→ 이건 그냥 `a`, `b`, `c` **값**이 순서대로 출력됨.  
**이터러블(반복 가능한 자료구조)**만 쓸 수 있고,  
중간에 배열을 바꿔도 순서에 영향을 거의 안 줌.

---



---

필요하다면 `forEach`, `map`, `Object.keys` 같은 것도 함께 비교해줄게!