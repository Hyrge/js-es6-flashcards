
> [!summary]
> - var은 `undefined`으로 초기화됨 
> - let, const는 선언 지점에서 초기화 됨
> - const 는 값도 필요함 



> **let과 const도 "호이스팅"은 된다. 하지만, 초기화되기 전까지는 접근할 수 없는 영역인 TDZ(Temporal Dead Zone)에 있게 된다.**

---

## 🔁 요약부터

|선언 키워드|호이스팅?|초기화 시점|선언 전 접근 가능?|TDZ 영향|
|---|---|---|---|---|
|`var`|✅|`undefined`로 초기화됨|가능 (undefined 반환)|없음|
|`let`|✅|선언 지점에서 초기화|❌ (ReferenceError)|있음|
|`const`|✅|선언 지점에서 초기화 + 값 필요|❌ (ReferenceError)|있음|

---

## 🧠 그럼 도대체 **호이스팅은 되는데 왜 접근이 안 돼?**

### 📌 자바스크립트 실행 흐름 (정확히 말하면 _Execution Context_ 생성 단계):

1. **선언이 먼저 '호이스팅'됨**: 모든 변수 선언은 코드 실행 전에 메모리에 기록됨.
2. `var`는 **초기값 `undefined`까지** 할당됨.
3. `let`, `const`는 선언은 되지만 **초기화는 안 됨**. 그래서 **TDZ(일시적 사각지대)** 상태가 생김.
    

---

## 🔥 TDZ란?

- **Temporal Dead Zone** = 변수는 스코프에 존재하지만 **초기화되기 전까지 접근 불가**
    
- 선언 지점까지 이 변수에 접근하면 `ReferenceError` 발생
    

```js
console.log(myVar);  // ❌ ReferenceError
let myVar = 3;
```

→ 이 `myVar`는 호이스팅되었지만, 선언 시점까지는 **TDZ에 묶여 있어서 접근 불가**

```js
{
  // TDZ 시작
  // 접근 불가
  let foo = 1; // TDZ 끝 → 여기서부터 접근 가능
}
```

---

## 📌 왜 이렇게 만들어놨을까?

- `undefined`를 자동으로 할당해주는 `var`의 특성은 **실수 유발** 가능성이 큼
    
- `let`, `const`는 **명확하게 선언 이후에만 사용할 수 있게** 해서 **버그를 줄이고 디버깅을 쉽게 하기 위함**
    

---

## 🎯 정리 문장

> `let`과 `const`는 선언만 호이스팅되고, 초기화는 선언문을 만나는 순간 이루어진다. 이 전에 접근하면 TDZ 때문에 `ReferenceError`가 발생한다.

---

필요하면 그림이나 실행 흐름 시각화도 그려줄 수 있어!